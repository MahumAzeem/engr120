#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    ArmPot,         sensorPotentiometer)
#pragma config(Sensor, in3,    IRsensor1,      sensorReflection)
#pragma config(Sensor, dgtl2,  Led3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  Led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  Led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  SonarIn,        sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  Button4,        sensorTouch)
#pragma config(Sensor, dgtl10, Button3,        sensorTouch)
#pragma config(Sensor, dgtl11, Button2,        sensorTouch)
#pragma config(Sensor, dgtl12, Button1,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           LeftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port9,           Arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          RightMotor,    tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//----------Global Variable Declaration-------//
const int driveSpeed = 50;
const int light_threshold = 150;
bool button1_pushed;
bool button2_pushed;
bool button3_pushed;
bool button4_pushed;
bool beaconVisible;
int distance;
int distanceHalf;
int count = 0;

//----------------monitorInput-----------------//
void monitorInput() //check for buttons
{
	if(SensorValue(Button1))
	{
		button1_pushed = true;
	}

	if(SensorValue(Button2))
	{
		button2_pushed = true;
	}

	if(SensorValue(Button3))
	{
		button3_pushed = true;
	}

	if(SensorValue(Button4))
	{
		button4_pushed = true;
	}
}


//----------------monitorLight----------------//
bool monitorLight()
{
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IRsensor1];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		}
	else {

		// Check for new minimum/maximum light levels.
			if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			}
			else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
			}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		SensorValue[Led1]=0;
		} else {
		returnValue = false;
	}

	return(returnValue);
}//end of monitor light


//----------------Motor Functions----------------//
void StopMotors(){
	motor[LeftMotor]  = 0;
	motor[RightMotor] = 0;
	motor[Arm]=0;
}
void Straight(int m){
	motor[LeftMotor]  = m;
	motor[RightMotor] = m;
}
void TurnRight (int m){
	motor[LeftMotor]  =  m;
	motor[RightMotor] = -m;
}
void TurnLeft (int m){
	motor[LeftMotor]  = -m;
	motor[RightMotor] =  m;
}



/*=================================================*/
/*             ***Main Function***                 */
/*=================================================*/

task main()
{
	typedef enum {
	STOP = 0,
	FORWARD,
	SCAN,
	CONNECT,
	SIGNAL_COMPLETION
}T_State ;

	SensorValue[Led1] = 1;

	T_State robot_state = SCAN; //define the starting state

	delay(1000);

	//start of infinite while loop
	while( true ) {
		monitorInput();

		beaconVisible = monitorLight();
		switch( robot_state ) {

		//-----------CASE 1:STOP----------//
		case STOP:
			monitorInput();
			StopMotors();
			if (button1_pushed){
				robot_state = SCAN;
				}//if butt 1
			else{
				robot_state = STOP;
				}//else
			break;
		//end of STOP

		//-----------CASE 2:FORWARD----------//
		case FORWARD:

			delay(1000);
			while (true ){


			monitorInput();

			if (button1_pushed ) {
					Straight(-30);
					delay(1000);
					TurnLeft(50);
					delay(1000);
					Straight(-30);
					delay(1000);
					robot_state = SCAN;
					//StopMotors();
					button1_pushed = false;
					break;
			}
			if (button2_pushed ) {
					Straight(-30);
					delay(1000);
					TurnRight(50);
					delay(1000);
					Straight(-30);
					delay(1000);
					robot_state = SCAN;
					//StopMotors();
					button2_pushed = false;
					break;
			}
			if(button3_pushed || button4_pushed){
					button3_pushed=false;
					button4_pushed=false;
					Straight(30);
					delay(1000);
				}
			//////////


			///sonar checks ////

			if (SensorValue[SonarIn] > 21){
					//SensorValue[Led2]=0;
					Straight(40);
			}

			if (SensorValue[SonarIn] < 19){
					//SensorValue[Led2]=0;
					Straight(-25);
			}
			beaconVisible = monitorLight();
			if ((SensorValue[SonarIn] == 19 ||SensorValue[SonarIn] == 20 ||SensorValue[SonarIn] == 21) && beaconVisible){
					StopMotors();
					delay(2000);

					StopMotors();

					robot_state = CONNECT;
					break;
			}
			if ((SensorValue[SonarIn] == 19 ||SensorValue[SonarIn] == 20 ||SensorValue[SonarIn] == 21) && !beaconVisible){
					Straight(50);
					delay(3000);


					StopMotors();

					robot_state = SCAN;
					break;
			}
			////end of sonar checks


			}//while

			break;

		//-----------CASE 3:SCAN----------//
		case SCAN:
			if(beaconVisible){
				motor[LeftMotor]=0;
				motor[RightMotor]=0;
				robot_state = FORWARD;

					TurnLeft(35);
					delay(800);
					StopMotors();

			} else {
				TurnLeft(40);
				SensorValue[Led1]=1;
			}

			monitorInput();

			if (button1_pushed ) {
					Straight(-30);
					delay(1000);
					TurnLeft(50);
					delay(1000);
					//StopMotors();
					button1_pushed = false;
			}
			if (button2_pushed ) {
					Straight(-30);
					delay(1000);
					TurnRight(50);
					delay(1000);
					//StopMotors();
					button2_pushed = false;
			}
			if(button3_pushed || button4_pushed){
					button3_pushed=false;
					button4_pushed=false;
					Straight(30);
					delay(1000);
				}

			break;
		//end of SCAN

		//-----------CASE 4:CONNECT----------//
		case CONNECT:


			delay(1000);
			while (SensorValue[ArmPot] != 30){
				motor[Arm] = 30;
			}
			motor[Arm] = 0;
			robot_state = SIGNAL_COMPLETION;
			break;

		//-----------CASE 5:SIGNAL_COMPLETION----------//
		case SIGNAL_COMPLETION:
			SensorValue[Led1]=0;
			robot_state = SIGNAL_COMPLETION;
			break;


		default:
			// This should never happen.


		} // switch( robot_state)

	}  // while(true)

}
/*-------------------------------------------END OF PROGRAM-----------------------------------------------*/
